## 과제 체크포인트

### 배포 링크
[https://jihoon-0330.github.io/front_6th_chapter1-1](https://jihoon-0330.github.io/front_6th_chapter1-1)

### 기본과제

#### 상품목록

**상품 목록 로딩**

- [✅] 페이지 접속 시 로딩 상태가 표시된다
- [✅] 데이터 로드 완료 후 상품 목록이 렌더링된다

**상품 목록 조회**

- [✅] 각 상품의 기본 정보(이미지, 상품명, 가격)가 카드 형태로 표시된다

**한 페이지에 보여질 상품 수 선택**

- [✅] 드롭다운에서 10, 20, 50, 100개 중 선택할 수 있으며 기본 값은 20개 이다.
- [✅] 선택 변경 시 즉시 목록에 반영된다

**상품 정렬 기능**

- [✅] 상품을 가격순/인기순으로 오름차순/내림차순 정렬을 할 수 있다.
- [✅] 드롭다운을 통해 정렬 기준을 선택할 수 있다
- [✅] 정렬 변경 시 즉시 목록에 반영된다

**무한 스크롤 페이지네이션**

- [✅] 페이지 하단 근처 도달 시 다음 페이지 데이터가 자동 로드된다
- [✅] 스크롤에 따라 계속해서 새로운 상품들이 목록에 추가된다
- [✅] 새 데이터 로드 중일 때 로딩 인디케이터와 스켈레톤 UI가 표시된다
- [✅] 홈 페이지에서만 무한 스크롤이 활성화된다

**상품을 장바구니에 담기**

- [✅] 각 상품에 장바구니 추가 버튼이 있다
- [✅] 버튼 클릭 시 해당 상품이 장바구니에 추가된다
- [✅] 추가 완료 시 사용자에게 알림이 표시된다

**상품 검색**

- [✅] 상품명 기반 검색을 위한 텍스트 입력 필드가 있다
- [✅] 검색 버튼 클릭으로 검색이 수행된다
- [✅] Enter 키로 검색이 수행된다
- [✅] 검색어와 일치하는 상품들만 목록에 표시된다

**카테고리 선택**

- [✅] 사용 가능한 카테고리들을 선택할 수 있는 UI가 제공된다
- [✅] 선택된 카테고리에 해당하는 상품들만 표시된다
- [✅] 전체 상품 보기로 돌아갈 수 있다
- [✅] 2단계 카테고리 구조를 지원한다 (1depth, 2depth)

**카테고리 네비게이션**

- [✅] 현재 선택된 카테고리 경로가 브레드크럼으로 표시된다
- [✅] 브레드크럼의 각 단계를 클릭하여 상위 카테고리로 이동할 수 있다
- [✅] "전체" > "1depth 카테고리" > "2depth 카테고리" 형태로 표시된다

**현재 상품 수 표시**

- [✅] 현재 조건에서 조회된 총 상품 수가 화면에 표시된다
- [✅] 검색이나 필터 적용 시 상품 수가 실시간으로 업데이트된다

#### 장바구니

**장바구니 모달**

- [✅] 장바구니 아이콘 클릭 시 모달 형태로 장바구니가 열린다
- [✅] X 버튼이나 배경 클릭으로 모달을 닫을 수 있다
- [✅] ESC 키로 모달을 닫을 수 있다
- [✅] 모달에서 장바구니의 모든 기능을 사용할 수 있다

**장바구니 수량 조절**

- [✅] 각 장바구니 상품의 수량을 증가할 수 있다
- [✅] 각 장바구니 상품의 수량을 감소할 수 있다
- [✅] 수량 변경 시 총 금액이 실시간으로 업데이트된다

**장바구니 삭제**

- [✅] 각 상품에 삭제 버튼이 배치되어 있다
- [✅] 삭제 버튼 클릭 시 해당 상품이 장바구니에서 제거된다

**장바구니 선택 삭제**

- [✅] 각 상품에 선택을 위한 체크박스가 제공된다
- [✅] 선택 삭제 버튼이 있다
- [✅] 체크된 상품들만 일괄 삭제된다

**장바구니 전체 선택**

- [✅] 모든 상품을 한 번에 선택할 수 있는 마스터 체크박스가 있다
- [✅] 전체 선택 시 모든 상품의 체크박스가 선택된다
- [✅] 전체 해제 시 모든 상품의 체크박스가 해제된다

**장바구니 비우기**

- [✅] 장바구니에 있는 모든 상품을 한 번에 삭제할 수 있다

#### 상품 상세

**상품 클릭시 상세 페이지 이동**

- [✅] 상품 목록에서 상품 이미지나 상품 정보 클릭 시 상세 페이지로 이동한다
- [✅] URL이 `/product/{productId}` 형태로 변경된다
- [✅] 상품의 자세한 정보가 전용 페이지에서 표시된다

**상품 상세 페이지 기능**

- [✅] 상품 이미지, 설명, 가격 등의 상세 정보가 표시된다
- [✅] 전체 화면을 활용한 상세 정보 레이아웃이 제공된다

**상품 상세 - 장바구니 담기**

- [✅] 상품 상세 페이지에서 해당 상품을 장바구니에 추가할 수 있다
- [✅] 페이지 내에서 수량을 선택하여 장바구니에 추가할 수 있다
- [✅] 수량 증가/감소 버튼이 제공된다

**관련 상품 기능**

- [✅] 상품 상세 페이지에서 관련 상품들이 표시된다
- [✅] 같은 카테고리(category2)의 다른 상품들이 관련 상품으로 표시된다
- [✅] 관련 상품 클릭 시 해당 상품의 상세 페이지로 이동한다
- [✅] 현재 보고 있는 상품은 관련 상품에서 제외된다

**상품 상세 페이지 내 네비게이션**

- [✅] 상품 상세에서 상품 목록으로 돌아가는 버튼이 제공된다
- [✅] 브레드크럼을 통해 카테고리별 상품 목록으로 이동할 수 있다
- [✅] SPA 방식으로 페이지 간 이동이 부드럽게 처리된다

#### 사용자 피드백 시스템

**토스트 메시지**

- [✅] 장바구니 추가 시 성공 메시지가 토스트로 표시된다
- [✅] 장바구니 삭제, 선택 삭제, 전체 삭제 시 알림 메시지가 표시된다
- [✅] 토스트는 3초 후 자동으로 사라진다
- [✅] 토스트에 닫기 버튼이 제공된다
- [✅] 토스트 타입별로 다른 스타일이 적용된다 (success, info, error)

### 심화과제

#### SPA 네비게이션 및 URL 관리

**페이지 이동**

- [✅] 어플리케이션 내의 모든 페이지 이동(뒤로가기/앞으로가기를 포함)은 하여 새로고침이 발생하지 않아야 한다.

**상품 목록 - URL 쿼리 반영**

- [✅] 검색어가 URL 쿼리 파라미터에 저장된다
- [✅] 카테고리 선택이 URL 쿼리 파라미터에 저장된다
- [✅] 상품 옵션이 URL 쿼리 파라미터에 저장된다
- [✅] 정렬 조건이 URL 쿼리 파라미터에 저장된다
- [✅] 조건 변경 시 URL이 자동으로 업데이트된다
- [✅] URL을 통해 현재 검색/필터 상태를 공유할 수 있다

**상품 목록 - 새로고침 시 상태 유지**

- [✅] 새로고침 후 URL 쿼리에서 검색어가 복원된다
- [✅] 새로고침 후 URL 쿼리에서 카테고리가 복원된다
- [✅] 새로고침 후 URL 쿼리에서 옵션 설정이 복원된다
- [✅] 새로고침 후 URL 쿼리에서 정렬 조건이 복원된다
- [✅] 복원된 조건에 맞는 상품 데이터가 다시 로드된다

**장바구니 - 새로고침 시 데이터 유지**

- [✅] 장바구니 내용이 브라우저에 저장된다
- [✅] 새로고침 후에도 이전 장바구니 내용이 유지된다
- [✅] 장바구니의 선택 상태도 함께 유지된다

**상품 상세 - URL에 ID 반영**

- [✅] 상품 상세 페이지 이동 시 상품 ID가 URL 경로에 포함된다 (`/product/{productId}`)
- [✅] URL로 직접 접근 시 해당 상품의 상세 페이지가 자동으로 로드된다

**상품 상세 - 새로고침시 유지**

- [✅] 새로고침 후에도 URL의 상품 ID를 읽어서 해당 상품 상세 페이지가 유지된다

**404 페이지**

- [✅] 존재하지 않는 경로 접근 시 404 에러 페이지가 표시된다
- [✅] 홈으로 돌아가기 버튼이 제공된다

#### AI로 한 번 더 구현하기

- [⏳] 기존에 구현한 기능을 AI로 다시 구현한다.
- [⏳] 이 과정에서 직접 가공하는 것은 최대한 지양한다.


## 과제 셀프회고

### 요구사항을 만족할 수 있는 구조를 설계하기

요구사항을 만족하지 못해, 컴포넌트, 이벤트 핸들러, 스토어와 같은 중요한 코드를 계속 변경했다. 수정이 빈번했기 때문에 3일 정도는 코드를 계속 갈아치우며 상품목록만 들여다 봤다. 이후에도 장바구니를 구현하며 코드를 수정해야 했다. 처음부터 요구사항을 만족할 수 있는 구조를 생각했다면 시간을 효율적으로 사용할 수 있었을 것이라 느꼈다.


### 우선 순위와 시간 관리하기

과제를 제출하는 것에 목표를 두니 당장 테스트 코드 하나 하나를 통과하는 것에만 집착을 했다 느껴진다. 과제를 하는 목적이 학습을 위한 것이기 때문에, 앞으론 제출에 대한 압박 보다는 중간 중간 학습한 내용을 문서로 정리하는 시간을 가져보는 것도 좋을 것 같다. 하루중 문서화를 위한 시간을 따로 가지는 것도 해보면 좋을 것 같다.


### 기술적 성장

#### 이벤트 위임

이벤트 위임을 어떻게 효율적으로 할 수 있을지 생각할 수 있는 시간이었다.
개발을 처음 공부할 때 요소별로 이벤트리스너를 설정해 성능 문제를 경험한 적이 있다.
그 이후론 '이벤트는 document 에 달아야지' 라는 생각을 해왔다.
과제를 진행하면서 처음엔 싱글톤을 이용해 document에 이벤트 타입별로 하나의 리스너만 유지할 수 있는 코드를 작성했다.
리스너를 하나로 유지하기 위해, 핸들러 함수를 Set에 저장하고 이벤트가 발생하면 Set에 있는 핸들러를 모두 호출하는 방식이다.
컴포넌트를 벗어나는 이벤트들도 핸들러로 실행되는 문제가 있어 이벤트 위임을 하면서 컴포넌트 안에서 실행이 가능하도록 한다는 고민을 하게 되었다.

#### 이벤트리스너를 어디에 할당할까?
바닐라 자바스크립트로 컴포넌트를 작성한 예시들을 보면 이벤트리스너를 document가 아닌 컴포넌트 요소에 할당하는 예시를 많이 볼 수 있었다.
정보를 더 찾아보니 몇가지 장점이 있었는데, 첫째는 이벤트 핸들러가 실행되는 것을 컴포넌트 하위로 제한하기 때문에 document에 위임하는 것 보다 예측하기 쉬워진다. 둘째는 리렌더링이 발생하면서 요소가 변경 되었을 때 요소가 더이상 존재하지 않기 때문에 GC에 의해 이벤트리스너가 수거될 가능성이 있다. removeEventListener 매서드로 해제하지 않아도 큰 문제가 없을 수 있다는 점이다. 단점도 존재했는데, 첫째는 리렌더링마다 이벤트리스너를 다시 할당해줘야 한다. 둘쨰는 컴포넌트가 많아지면 결국 이벤트리스너 수가 많아진다는 점이다.

#### 이벤트리스너를 최소화 하며 컴포넌트 별로 격리 시키기
이벤트리스너 수를 최소화 하면서 컴포넌트 별로 핸들러를 격리 시키기를 원했다.
처음 생각했던 것 처럼 이벤트리스너를 document로 관리하는 싱글톤 클래스를 활용하고, 컴포넌트 별로 생성자에서 고유한 id를 생성하는 구조를 만들었다.
```
{
  eventType: {
    componentId: [{selector, handler}, {selector, handler}, ...]
  }
}
```
이벤트 타입에 컴포넌트 별로 selector와 handler의 목록을 저장한다.
이벤트가 발생하면 closest 매서드를 활용해 어떤 컴포넌트에서 발생한 이벤트인지 추적하고, closest 매서드를 활용해 가장 먼저 만난 조상 selector의 핸들러만 호출한다.
주의할 점은 자식 컴포넌트가 부모 컴포넌트 보다 먼저 생성자가 호출되어야 하는 것과, selector와 handler를 선언할 때 더 작은 요소를 먼저 배치해야 한다는 점이다.

#### 반응형 시스템

개인적으로 반응형 시스템을 이해하고 적용하는 것이 가장 어려웠다.
NHN Cloud 게시글인 '0.7KB로 Vue와 같은 반응형 시스템 만들기' 와 준일 코치님 'Vanilla Javascript로 상태관리 시스템 만들기' 게시글을 많이 참고했다.
처음엔 블로그에 있는 코드를 한 줄 씩 따라서 작성하고 실행 시켜가며 동작원리를 파악했다.

#### 상태 변경 추적하기

반응형 시스템의 원리는 값이 바뀌었을 때 알려준다






<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

### 자랑하고 싶은 코드

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

### 개선이 필요하다고 생각하는 코드

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

### 학습 효과 분석

<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
-->

### 과제 피드백

<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->

### AI 활용 경험 공유하기

<!-- 예시
- 사용한 AI 도구 (예: ChatGPT, Copilot, Claude, Cursor, ...)
- 프롬프트를 작성한 과정
- AI가 일을 더 잘 하게 만든 방법
- 내가 작성한 코드와 비교하기
-->

## 리뷰 받고 싶은 내용

<!--
피드백 받고 싶은 내용을 구체적으로 남겨주세요
모호한 요청은 피드백을 남기기 어렵습니다.

참고링크: https://chatgpt.com/share/675b6129-515c-8001-ba72-39d0fa4c7b62

모호한 질문의 예시)
- 무엇을 질문해야 할지 몰라서 코치님이 보시기에 고쳐야할것들 전반적으로 피드백 부탁드립니다.
- 코드 스타일에 대한 피드백 부탁드립니다.
- 코드 구조에 대한 피드백 부탁드립니다.
- 개념적인 오류에 대한 피드백 부탁드립니다.
- 추가 구현이 필요한 부분에 대한 피드백 부탁드립니다.

구체적인 질문의 예시)
- 파일A의 함수B와 그 안의 변수명을 보면 직관성이 떨어지는 것 같습니다. 함수와 변수 이름을 더 명확하게 지을 방법에 대해 조언해 주실 수 있나요?
- 현재 파일 단위로 코드를 분리했지만, 이번 주차 발제를 기준으로 봤을 때 모듈화나 계층화에서 부족함이 있는 것 같습니다. 특히 A와 B 부분에서 모듈화를 더 진행할지 그대로 둘지 고민하였습니다. (...구체적인 고민 사항 적기...). 코치님의 의견이 궁금합니다.
- 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요?
- 컴포넌트 A를 테스트 할 때 B와의 의존성 때문에 테스트 코드를 작성하려다 포기했습니다. A와 B의 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?
-->